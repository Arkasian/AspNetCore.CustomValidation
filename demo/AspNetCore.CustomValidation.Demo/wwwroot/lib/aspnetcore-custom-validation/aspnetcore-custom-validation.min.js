// Unobtrusive validation support library for AspNetCore.CustomValidation library
// Copyright (c) TanvirArjel. All rights reserved.
// Licensed under the MIT License, Version 2.0. See License.txt in the project root for license information.
// @version v1.1.0

!function (e) { e.validator.setDefaults({ onfocusout: function (e, t) { 9 === t.which && "" === this.elementValue(e) || this.element(e) } }); var t = function (e) { return "Invalid Date" !== new Date(e).toString() && !isNaN(new Date(e)) }, a = function (e) { if (t(e)) { if (/\d{4}-\d{2}-\d{2}/i.test(e)) { return -1 === e.indexOf("T") ? new Date(e + "T00:00:00") : new Date(e) } return new Date(e) } throw { name: "InvalidDateTimeFormat", message: "Input date/datetime is not in valid format. Please enter the date in valid datetime format. Prefer: '01-Jan-1999' format." } }; e.validator.addMethod("valid-date-format", function (e, a, r) { return !e || t(e) }), e.validator.unobtrusive.adapters.add("valid-date-format", [], function (e) { e.rules["valid-date-format"] = {}, e.messages["valid-date-format"] = e.message }), e.validator.addMethod("mindate", function (e, t, r) { if (e) { const t = new Date(r.date); return a(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("mindate", ["date"], function (e) { e.rules.mindate = e.params, e.messages.mindate = e.message }), e.validator.addMethod("maxdate", function (e, t, r) { if (e) { const t = new Date(r.date); return a(e) <= t } return !0 }), e.validator.unobtrusive.adapters.add("maxdate", ["date"], function (e) { e.rules.maxdate = e.params, e.messages.maxdate = e.message }), e.validator.addMethod("currenttime", function (e, t, r) { if (e) { return new Date > a(e) } return !0 }), e.validator.unobtrusive.adapters.add("currenttime", [], function (e) { e.rules.currenttime = {}, e.messages.currenttime = e.message }), e.validator.addMethod("maxage", function (e, t, r) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - r.years), t.setMonth(t.getMonth() - r.months), t.setDate(t.getDate() - r.days), a(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("maxage", ["years", "months", "days"], function (e) { e.rules.maxage = e.params, e.messages.maxage = e.message }), e.validator.addMethod("minage", function (e, t, r) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - r.years), t.setMonth(t.getMonth() - r.months), t.setDate(t.getDate() - r.days), t >= a(e) } return !0 }), e.validator.unobtrusive.adapters.add("minage", ["years", "months", "days"], function (e) { e.rules.minage = e.params, e.messages.minage = e.message }), e.validator.addMethod("filetype", function (e, t, a) { var r = e.split(".").pop(); return -1 !== a.validtypes.toLowerCase().indexOf(r.toLowerCase()) }), e.validator.unobtrusive.adapters.add("filetype", ["validtypes"], function (e) { e.rules.filetype = e.params, e.messages.filetype = e.message }), e.validator.addMethod("file-minsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 >= r } return !0 }), e.validator.unobtrusive.adapters.add("file-minsize", ["value"], function (e) { e.rules["file-minsize"] = e.params, e.messages["file-minsize"] = e.message }), e.validator.addMethod("file-maxsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 <= r } return !0 }), e.validator.unobtrusive.adapters.add("file-maxsize", ["value"], function (e) { e.rules["file-maxsize"] = e.params, e.messages["file-maxsize"] = e.message }), e.validator.addMethod("input-type-compare", function (t, a, r) { var n = e(a).prop("type"), i = r.property; return n === e(a).closest("form").find('input[name="' + i + '"]').prop("type") }), e.validator.unobtrusive.adapters.add("input-type-compare", ["property"], function (e) { e.rules["input-type-compare"] = e.params, e.messages["input-type-compare"] = e.message }), e.validator.addMethod("comparison-equality", function (r, n, i) { const s = r, o = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('input[name="' + d + '"]'), m = u.prop("type"), l = u.val(); if (s && l) { if ("number" === o && o === m) return Number(r) === Number(u.val()); if ("text" === o && o === m) { if (t(s) && t(l)) { const e = a(s), t = a(l); return e.getTime() === t.getTime() } return s.length === l.length } if (-1 !== o.indexOf("date") && -1 !== m.indexOf("date")) { const e = a(r), t = a(l); return e.getTime() === t.getTime() } } return !0 }), e.validator.unobtrusive.adapters.add("comparison-equality", ["property"], function (e) { e.rules["comparison-equality"] = e.params, e.messages["comparison-equality"] = e.message }), e.validator.addMethod("comparison-not-equality", function (r, n, i) { const s = r, o = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('input[name="' + d + '"]'), m = u.prop("type"), l = u.val(); if (s && l) { if ("number" === o && o === m) return Number(r) !== Number(u.val()); if ("text" === o && o === m) { if (t(s) && t(l)) { const e = a(s), t = a(l); return e.getTime() !== t.getTime() } return s.length !== l.length } if (-1 !== o.indexOf("date") && -1 !== m.indexOf("date")) { const e = a(r), t = a(l); return e.getTime() !== t.getTime() } } return !0 }), e.validator.unobtrusive.adapters.add("comparison-not-equality", ["property"], function (e) { e.rules["comparison-not-equality"] = e.params, e.messages["comparison-not-equality"] = e.message }), e.validator.addMethod("comparison-greater", function (r, n, i) { const s = r; let o = e(n).prop("type"); const d = i.property, u = e(n).closest("form").find('input[name="' + d + '"]'), m = u.prop("type"), l = u.val(); if (s && l) { if ("number" === o && o === m) return Number(s) > Number(l); if ("text" === o && o === m) { if (t(s) && t(l)) { return a(s) > a(l) } return s.length > l.length } if (-1 !== o.indexOf("date") && -1 !== m.indexOf("date")) { return a(r) > a(l) } } return !0 }), e.validator.unobtrusive.adapters.add("comparison-greater", ["property"], function (e) { e.rules["comparison-greater"] = e.params, e.messages["comparison-greater"] = e.message }), e.validator.addMethod("comparison-smaller", function (r, n, i) { const s = r, o = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('input[name="' + d + '"]'), m = u.prop("type"), l = u.val(); if (s && l) { if ("number" === o && o === m) return Number(s) < Number(l); if ("text" === o && o === m) { if (t(s) && t(l)) { return a(s) < a(l) } return s.length < l.length } if (-1 !== o.indexOf("date") && -1 !== m.indexOf("date")) { return a(r) < a(l) } } return !0 }), e.validator.unobtrusive.adapters.add("comparison-smaller", ["property"], function (e) { e.rules["comparison-smaller"] = e.params, e.messages["comparison-smaller"] = e.message }), e.validator.addMethod("tinymce-required", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "); return " " !== n && n.length > 0 }), e.validator.unobtrusive.adapters.add("tinymce-required", [], function (e) { e.rules["tinymce-required"] = e.params, e.messages["tinymce-required"] = e.message }), e.validator.addMethod("tinymce-minlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length >= i }), e.validator.unobtrusive.adapters.add("tinymce-minlength", ["value"], function (e) { e.rules["tinymce-minlength"] = e.params, e.messages["tinymce-minlength"] = e.message }), e.validator.addMethod("tinymce-maxlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length <= i }), e.validator.unobtrusive.adapters.add("tinymce-maxlength", ["value"], function (e) { e.rules["tinymce-maxlength"] = e.params, e.messages["tinymce-maxlength"] = e.message }) }(jQuery);